<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Templa: C:/Users/aryas/OneDrive/Desktop/C++Projects/Templa/include/templa-include/algorithms.hpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Templa<span id="projectnumber">&#160;0.0.1-alpha</span>
   </div>
   <div id="projectbrief">C++ Metaprogramming Utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('_c_1_2_users_2aryas_2_one_drive_2_desktop_2_c_09_09_projects_2_templa_2include_2templa-include_2algorithms_8hpp-example.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">C:/Users/aryas/OneDrive/Desktop/C++Projects/Templa/include/templa-include/algorithms.hpp</div></div>
</div><!--header-->
<div class="contents">
<p>Applies a callable to the result of concatenating multiple tuples.</p>
<p>Applies a callable to the result of concatenating multiple tuples.Combines the input tuples using <span class="tt">std::tuple_cat</span>, then invokes the callable with the elements of the concatenated tuple via <span class="tt">std::apply</span>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Callable</td><td>A function, lambda, or callable object that accepts the unpacked elements of the concatenated tuple. </td></tr>
    <tr><td class="paramname">Ts</td><td>Parameter pack of tuple types (e.g., <span class="tt">std::tuple&lt;...&gt;</span>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The callable to invoke with the unpacked concatenated tuple. </td></tr>
    <tr><td class="paramname">tuples</td><td>The input tuples to be concatenated and passed to the callable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All input tuples must be compatible with <span class="tt">std::tuple_cat</span>.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> t1 = std::make_tuple(1, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"><span class="keyword">auto</span> t2 = std::make_tuple(3.14);</div>
<div class="line">apply_to_tuple_cat([](<span class="keywordtype">int</span> i, <span class="keywordtype">char</span> c, <span class="keywordtype">double</span> d) {</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}, t1, t2);</div>
<div class="line"><span class="comment">// Output: 1, a, 3.14</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="concepts_8hpp.html">concepts.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="pack_8hpp.html">pack.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;static_for.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>templa::algorithms</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Formats, std::size_t N, std::size_t... Is&gt;</div>
<div class="line">    std::tuple&lt;Formats...&gt; <a id="a0" name="a0"></a>as_tuple(std::array&lt;T, N&gt; <span class="keyword">const</span> &amp;arr, std::index_sequence&lt;Is...&gt;)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::make_tuple(Formats{arr[Is]}...);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Formats, std::size_t N&gt;</div>
<div class="line">    std::tuple&lt;Formats...&gt; as_tuple(std::array&lt;T, N&gt; <span class="keyword">const</span> &amp;arr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> as_tuple&lt;Formats...&gt;(arr, std::make_index_sequence&lt;N&gt;{});</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, std::size_t... I&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> zip(T1 <span class="keyword">const</span> &amp;t1, T2 <span class="keyword">const</span> &amp;t2, std::index_sequence&lt;I...&gt;)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::make_tuple((std::pair{std::get&lt;I&gt;(t1), std::get&lt;I&gt;(t2)})...);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts, <span class="keyword">typename</span>... Us&gt;</div>
<div class="line">        <span class="keyword">requires</span>(<span class="keyword">sizeof</span>...(Ts) == <span class="keyword">sizeof</span>...(Us))</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> zip(std::tuple&lt;Ts...&gt; <span class="keyword">const</span> &amp;t1, std::tuple&lt;Us...&gt; <span class="keyword">const</span> &amp;t2)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> zip(t1, t2, std::make_index_sequence&lt;<span class="keyword">sizeof</span>...(Ts)&gt;{});</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">namespace </span>internal</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::size_t N, std::size_t M, std::size_t... I, std::size_t... J&gt;</div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> concat_impl(std::array&lt;T, N&gt; <span class="keyword">const</span> &amp;lhs, std::array&lt;T, M&gt; <span class="keyword">const</span> &amp;rhs, std::index_sequence&lt;I...&gt;, std::index_sequence&lt;J...&gt;)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> std::array&lt;T, N + M&gt;{lhs[I]..., rhs[J]...};</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line">        <span class="keyword">consteval</span> <span class="keyword">static</span> <span class="keywordtype">bool</span> exists_until(std::array&lt;T, N&gt; <span class="keyword">const</span> &amp;arr, <span class="keyword">const</span> T &amp;elem, std::size_t until)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; until; i++)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (arr[i] == elem)</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line">        <span class="keyword">consteval</span> <span class="keyword">static</span> std::size_t count_unique(std::array&lt;T, N&gt; <span class="keyword">const</span> &amp;arr)</div>
<div class="line">        {</div>
<div class="line">            std::size_t cnt = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; N; i++)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (!internal::exists_until(arr, arr[i], i))</div>
<div class="line">                    cnt++;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> cnt;</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">auto</span>... Es&gt;</div>
<div class="line">    <span class="keyword">struct </span>min : <a id="_a1" name="_a1"></a><a class="code hl_struct" href="structtempla_1_1internal_1_1uniform__element__identity.html">templa::internal::uniform_element_identity</a>&lt;Es...&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using </span><a id="a2" name="a2"></a><a class="code hl_typedef" href="structtempla_1_1algorithms_1_1min.html#a66b7ca991841bfc39b1e80f434c1ce47">identity_type</a> = <span class="keyword">typename</span> <a class="code hl_struct" href="structtempla_1_1internal_1_1uniform__element__identity.html">templa::internal::uniform_element_identity</a>&lt;Es...&gt;;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">using </span>typename identity_type::value_type;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <a id="a3" name="a3"></a><a class="code hl_typedef" href="structtempla_1_1internal_1_1uniform__element__identity.html#a34177c2d47c12125d0992c64cfa62fb3">value_type</a> <a id="a4" name="a4"></a><a class="code hl_variable" href="structtempla_1_1algorithms_1_1min.html#aa081c0654583122b8e2102e119393130">value</a> =</div>
<div class="line">            *std::min_element(identity_type::identity_value.begin(), identity_type::identity_value.end());</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;auto e&gt;</div>
<div class="line">        <span class="keyword">requires</span>(concepts::Container&lt;std::remove_cv_t&lt;<span class="keyword">decltype</span>(e)&gt;&gt;)</div>
<div class="line">    <span class="keyword">struct</span> min_from</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">using </span>type = <span class="keyword">typename</span> <span class="keyword">decltype</span>(e)::value_type;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> std::size_t size = e.size();</div>
<div class="line"></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> <a id="a5" name="a5"></a>value =</div>
<div class="line">            []&lt;std::size_t... I&gt;(std::index_sequence&lt;I...&gt;) <span class="keyword">consteval</span> <span class="keyword">noexcept</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> min&lt;e[I]...&gt;::value;</div>
<div class="line">        }(std::make_index_sequence&lt;size&gt;{});</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">auto</span>... Es&gt;</div>
<div class="line">    <span class="keyword">struct </span>max : <a class="code hl_struct" href="structtempla_1_1internal_1_1uniform__element__identity.html">templa::internal::uniform_element_identity</a>&lt;Es...&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using </span><a id="a6" name="a6"></a><a class="code hl_typedef" href="structtempla_1_1algorithms_1_1max.html#a47b1051362cc5377535d0ec540ce08e5">identity_type</a> = <span class="keyword">typename</span> <a class="code hl_struct" href="structtempla_1_1internal_1_1uniform__element__identity.html">templa::internal::uniform_element_identity</a>&lt;Es...&gt;;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">using </span>typename identity_type::value_type;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <a class="code hl_typedef" href="structtempla_1_1internal_1_1uniform__element__identity.html#a34177c2d47c12125d0992c64cfa62fb3">value_type</a> <a id="a7" name="a7"></a><a class="code hl_variable" href="structtempla_1_1algorithms_1_1max.html#a4ad55dc4f20b585d771baad790e50f90">value</a> =</div>
<div class="line">            *std::max_element(identity_type::identity_value.begin(), identity_type::identity_value.end(),</div>
<div class="line">                              [](<span class="keyword">const</span> <a class="code hl_typedef" href="structtempla_1_1internal_1_1uniform__element__identity.html#a34177c2d47c12125d0992c64cfa62fb3">value_type</a> &amp;a, <span class="keyword">const</span> <a class="code hl_typedef" href="structtempla_1_1internal_1_1uniform__element__identity.html#a34177c2d47c12125d0992c64cfa62fb3">value_type</a> &amp;b)</div>
<div class="line">                              { <span class="keywordflow">return</span> a &lt; b; });</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;auto e&gt;</div>
<div class="line">        <span class="keyword">requires</span>(concepts::Container&lt;std::remove_cv_t&lt;<span class="keyword">decltype</span>(e)&gt;&gt;)</div>
<div class="line">    <span class="keyword">struct</span> max_from</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">using </span>type = <span class="keyword">typename</span> <span class="keyword">decltype</span>(e)::value_type;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> std::size_t size = e.size();</div>
<div class="line"></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> value =</div>
<div class="line">            []&lt;std::size_t... I&gt;(std::index_sequence&lt;I...&gt;) <span class="keyword">consteval</span> <span class="keyword">noexcept</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> max&lt;e[I]...&gt;::value;</div>
<div class="line">        }(std::make_index_sequence&lt;size&gt;{});</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">auto</span>... Es&gt;</div>
<div class="line">    <span class="keyword">struct </span>unique : <a class="code hl_struct" href="structtempla_1_1internal_1_1uniform__element__identity.html">templa::internal::uniform_element_identity</a>&lt;Es...&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using </span><a id="a8" name="a8"></a><a class="code hl_typedef" href="structtempla_1_1algorithms_1_1unique.html#a57ca143798c64061e87a587e379f1256">identity_type</a> = <span class="keyword">typename</span> <a class="code hl_struct" href="structtempla_1_1internal_1_1uniform__element__identity.html">templa::internal::uniform_element_identity</a>&lt;Es...&gt;;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">using </span><a id="a9" name="a9"></a><a class="code hl_typedef" href="structtempla_1_1algorithms_1_1unique.html#acc0d2c188afe3cd0ae5406397b7275b0">old_array_type</a> = <span class="keyword">typename</span> identity_type::uniform_type;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> <a id="a10" name="a10"></a><a class="code hl_variable" href="structtempla_1_1algorithms_1_1unique.html#aaf25d9685d1c733798ea8cd1f7d62dcd">unique_sequence</a> = []() <span class="keyword">consteval</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">constexpr</span> std::size_t n_unique = internal::count_unique(identity_type::identity_value);</div>
<div class="line">            std::array&lt;typename identity_type::value_type, n_unique&gt; new_arr{};</div>
<div class="line">            std::size_t idx = 0;</div>
<div class="line">            <span class="keyword">constexpr</span> <span class="keyword">auto</span> lam = []&lt;std::size_t... I&gt;(</div>
<div class="line">                                     std::array&lt;typename identity_type::value_type, n_unique&gt; &amp;n,</div>
<div class="line">                                     std::size_t &amp;idx)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">constexpr</span> <span class="keyword">auto</span> &amp;old = identity_type::identity_value;</div>
<div class="line">                ((!internal::exists_until(old, old[I], I) ? (n[idx++] = old[I], void()) : void()), ...);</div>
<div class="line">            };</div>
<div class="line">            static_for&lt;identity_type::size&gt;(lam, new_arr, idx);</div>
<div class="line">            <span class="keywordflow">return</span> new_arr;</div>
<div class="line">        }();</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;auto a&gt;</div>
<div class="line">        <span class="keyword">requires</span>(concepts::Container&lt;std::remove_cv_t&lt;<span class="keyword">decltype</span>(a)&gt;&gt;) &amp;&amp;</div>
<div class="line">                (concepts::Comparable&lt;std::remove_cv_t&lt;<span class="keyword">decltype</span>(a)&gt;&gt;)</div>
<div class="line">    <span class="keyword">struct </span>unique_from</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keyword">using </span>forwarded_type = <a id="_a11" name="_a11"></a><a class="code hl_struct" href="structtempla_1_1internal_1_1forward__elements__from.html">templa::internal::forward_elements_from&lt;a&gt;</a>;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">using </span>old_array_type = std::array&lt;typename forwarded_type::type, forwarded_type::size&gt;;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> old = <a id="_a12" name="_a12"></a><a class="code hl_variable" href="structtempla_1_1internal_1_1forward__elements__from.html#af0276070351472eb48e6b1cb13a9f5e7">templa::internal::forward_elements_from&lt;a&gt;::value</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> <a id="a13" name="a13"></a><a class="code hl_variable" href="structtempla_1_1algorithms_1_1unique__from.html#a7fe08bb2dbef104d7af77fbf5007d83e">unique_sequence</a> = []() <span class="keyword">consteval</span></div>
<div class="line">        {</div>
<div class="line">            std::array&lt;<span class="keyword">typename</span> <a id="a14" name="a14"></a><a class="code hl_typedef" href="structtempla_1_1internal_1_1forward__elements__from.html#a8481749e857c4a6908eeecd09acf7946">forwarded_type::type</a>, internal::count_unique(old)&gt; new_arr{};</div>
<div class="line">            std::size_t idx = 0;</div>
<div class="line">            <span class="keyword">constexpr</span> <span class="keyword">auto</span> lam = []&lt;std::size_t... I&gt;(</div>
<div class="line">                                     <span class="keyword">const</span> old_array_type &amp;o,</div>
<div class="line">                                     std::array&lt;<span class="keyword">typename</span> <a class="code hl_typedef" href="structtempla_1_1internal_1_1forward__elements__from.html#a8481749e857c4a6908eeecd09acf7946">forwarded_type::type</a>, internal::count_unique(old)&gt; &amp;n,</div>
<div class="line">                                     std::size_t &amp;idx)</div>
<div class="line">            {</div>
<div class="line">                ((!internal::exists_until(old, old[I], I) ? (n[idx++] = old[I], void()) : void()), ...);</div>
<div class="line">            };</div>
<div class="line">            static_for&lt;old.size()&gt;(lam, old, new_arr, idx);</div>
<div class="line">            <span class="keywordflow">return</span> new_arr;</div>
<div class="line">        }();</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">auto</span>... elems&gt;</div>
<div class="line">    <span class="keyword">struct </span>reverse : <a class="code hl_struct" href="structtempla_1_1internal_1_1uniform__element__identity.html">templa::internal::uniform_element_identity</a>&lt;elems...&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using </span><a id="a15" name="a15"></a><a class="code hl_typedef" href="structtempla_1_1algorithms_1_1reverse.html#a46438f8acfd35aafa66adc85e3830676">identity_type</a> = <span class="keyword">typename</span> <a class="code hl_struct" href="structtempla_1_1internal_1_1uniform__element__identity.html">templa::internal::uniform_element_identity</a>&lt;elems...&gt;;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">using </span><a id="a16" name="a16"></a><a class="code hl_typedef" href="structtempla_1_1algorithms_1_1reverse.html#a87255bbd9374fa7d78bb9a1ed94148f6">array_type</a> = <span class="keyword">typename</span> identity_type::uniform_type;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> <a id="a17" name="a17"></a><a class="code hl_variable" href="structtempla_1_1algorithms_1_1reverse.html#a078a650c51c35b40fde073e263b27b1b">reverse_sequence</a> = []()</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> lam = []&lt;std::size_t... I&gt;(<span class="keyword">const</span> <a class="code hl_typedef" href="structtempla_1_1algorithms_1_1reverse.html#a87255bbd9374fa7d78bb9a1ed94148f6">array_type</a> &amp;in, <a class="code hl_typedef" href="structtempla_1_1algorithms_1_1reverse.html#a87255bbd9374fa7d78bb9a1ed94148f6">array_type</a> &amp;out) <span class="keyword">constexpr</span></div>
<div class="line">            {</div>
<div class="line">                ((out[I] = in[in.size() - I - 1]), ...);</div>
<div class="line">            };</div>
<div class="line"> </div>
<div class="line">            std::array&lt;int, identity_type::size&gt; ret{};</div>
<div class="line">            static_for&lt;identity_type::size&gt;(lam, identity_type::identity_value, ret);</div>
<div class="line">            <span class="keywordflow">return</span> ret;</div>
<div class="line">        }();</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;auto a&gt;</div>
<div class="line">        <span class="keyword">requires</span>(concepts::Container&lt;std::remove_cv_t&lt;<span class="keyword">decltype</span>(a)&gt;&gt;)</div>
<div class="line">    <span class="keyword">struct</span> reverse_from</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> old = <a class="code hl_variable" href="structtempla_1_1internal_1_1forward__elements__from.html#af0276070351472eb48e6b1cb13a9f5e7">templa::internal::forward_elements_from&lt;a&gt;::value</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> reverse_sequence = []&lt;std::size_t... I&gt;(std::index_sequence&lt;I...&gt;)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(a) ret{old[a.size() - I - 1]...};</div>
<div class="line">            <span class="keywordflow">return</span> ret;</div>
<div class="line">        }(std::make_index_sequence&lt;a.size()&gt;{});</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="keywordtype">size_t</span> N, std::<span class="keywordtype">size_t</span> M&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> concat(<span class="keyword">const</span> std::array&lt;T, N&gt; &amp;lhs, <span class="keyword">const</span> std::array&lt;T, M&gt; &amp;rhs)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> internal::concat_impl(lhs, rhs, std::make_index_sequence&lt;N&gt;{}, std::make_index_sequence&lt;M&gt;{});</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">const</span> std::string_view &amp;...Strs&gt;</div>
<div class="line">    <span class="keyword">struct </span>join</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> arr = []() <span class="keyword">consteval</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">constexpr</span> std::size_t length = (Strs.size() + ... + 0);</div>
<div class="line">            std::array&lt;char, length + 1&gt; arr;</div>
<div class="line">            <span class="keyword">auto</span> Joiner = [i = 0, &amp;arr](<span class="keyword">const</span> std::string_view &amp;s) <span class="keyword">consteval</span> <span class="keyword">mutable</span></div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span> c : s)</div>
<div class="line">                {</div>
<div class="line">                    arr[i++] = c;</div>
<div class="line">                }</div>
<div class="line">            };</div>
<div class="line">            (Joiner(Strs), ...);</div>
<div class="line">            arr[length] = 0;</div>
<div class="line">            <span class="keywordflow">return</span> arr;</div>
<div class="line">        }();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> std::string_view <a id="a18" name="a18"></a><a class="code hl_variable" href="structtempla_1_1algorithms_1_1join.html#a0b0bec2ac22d682bea3a32618c3e5aa1">value</a> = {arr.data(), arr.size() - 1};</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;std::string_view <span class="keyword">const</span> &amp;...Strs&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> std::string_view join_v = join&lt;Strs...&gt;::value;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> O&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a id="a19" name="a19"></a>flatten(<span class="keyword">const</span> std::vector&lt;T&gt; &amp;in, std::vector&lt;O&gt; &amp;out)</div>
<div class="line">    {</div>
<div class="line">        out.insert(out.end(), in.begin(), in.end());</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> O&gt;</div>
<div class="line">    <span class="keywordtype">void</span> flatten(<span class="keyword">const</span> std::vector&lt;std::vector&lt;T&gt;&gt; &amp;in, std::vector&lt;O&gt; &amp;out)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : in)</div>
<div class="line">        {</div>
<div class="line">            flatten(e, out);</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Ts&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keywordtype">void</span> apply_to_tuple_cat(Callable &amp;&amp;c, Ts &amp;&amp;...tuples)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> cat = std::tuple_cat&lt;Ts...&gt;(std::forward&lt;Ts&gt;(tuples)...);</div>
<div class="line">        std::apply(std::forward&lt;Callable&gt;(c), std::move(cat));</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aconcepts_8hpp_html"><div class="ttname"><a href="concepts_8hpp.html">concepts.hpp</a></div><div class="ttdoc">Concepts.</div></div>
<div class="ttc" id="apack_8hpp_html"><div class="ttname"><a href="pack_8hpp.html">pack.hpp</a></div><div class="ttdoc">Internal utilities and implementation details.</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1join_html_a0b0bec2ac22d682bea3a32618c3e5aa1"><div class="ttname"><a href="structtempla_1_1algorithms_1_1join.html#a0b0bec2ac22d682bea3a32618c3e5aa1">templa::algorithms::join::value</a></div><div class="ttdeci">static constexpr std::string_view value</div><div class="ttdoc">The resulting joined string as a std::string_view.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:468</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1max_html_a47b1051362cc5377535d0ec540ce08e5"><div class="ttname"><a href="structtempla_1_1algorithms_1_1max.html#a47b1051362cc5377535d0ec540ce08e5">templa::algorithms::max::identity_type</a></div><div class="ttdeci">typename templa::internal::uniform_element_identity&lt; Es... &gt; identity_type</div><div class="ttdoc">The type that provides the uniform container of values.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:207</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1max_html_a4ad55dc4f20b585d771baad790e50f90"><div class="ttname"><a href="structtempla_1_1algorithms_1_1max.html#a4ad55dc4f20b585d771baad790e50f90">templa::algorithms::max::value</a></div><div class="ttdeci">static constexpr value_type value</div><div class="ttdoc">The maximum value among the compile-time constants.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:213</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1min_html_a66b7ca991841bfc39b1e80f434c1ce47"><div class="ttname"><a href="structtempla_1_1algorithms_1_1min.html#a66b7ca991841bfc39b1e80f434c1ce47">templa::algorithms::min::identity_type</a></div><div class="ttdeci">typename templa::internal::uniform_element_identity&lt; Es... &gt; identity_type</div><div class="ttdoc">Alias for the identity type that represents the uniform compile-time values.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:152</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1min_html_aa081c0654583122b8e2102e119393130"><div class="ttname"><a href="structtempla_1_1algorithms_1_1min.html#aa081c0654583122b8e2102e119393130">templa::algorithms::min::value</a></div><div class="ttdeci">static constexpr value_type value</div><div class="ttdoc">The minimum value among the compile-time constants.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:158</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1reverse_html_a078a650c51c35b40fde073e263b27b1b"><div class="ttname"><a href="structtempla_1_1algorithms_1_1reverse.html#a078a650c51c35b40fde073e263b27b1b">templa::algorithms::reverse::reverse_sequence</a></div><div class="ttdeci">static constexpr auto reverse_sequence</div><div class="ttdoc">The reversed array, computed at compile time.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:363</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1reverse_html_a46438f8acfd35aafa66adc85e3830676"><div class="ttname"><a href="structtempla_1_1algorithms_1_1reverse.html#a46438f8acfd35aafa66adc85e3830676">templa::algorithms::reverse::identity_type</a></div><div class="ttdeci">typename templa::internal::uniform_element_identity&lt; elems... &gt; identity_type</div><div class="ttdoc">The identity type wrapping the parameter pack.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:352</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1reverse_html_a87255bbd9374fa7d78bb9a1ed94148f6"><div class="ttname"><a href="structtempla_1_1algorithms_1_1reverse.html#a87255bbd9374fa7d78bb9a1ed94148f6">templa::algorithms::reverse::array_type</a></div><div class="ttdeci">typename identity_type::uniform_type array_type</div><div class="ttdoc">The array type representing the uniform values.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:355</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1unique__from_html_a7fe08bb2dbef104d7af77fbf5007d83e"><div class="ttname"><a href="structtempla_1_1algorithms_1_1unique__from.html#a7fe08bb2dbef104d7af77fbf5007d83e">templa::algorithms::unique_from::unique_sequence</a></div><div class="ttdeci">static constexpr auto unique_sequence</div><div class="ttdoc">The resulting array with unique elements from the input container.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:324</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1unique_html_a57ca143798c64061e87a587e379f1256"><div class="ttname"><a href="structtempla_1_1algorithms_1_1unique.html#a57ca143798c64061e87a587e379f1256">templa::algorithms::unique::identity_type</a></div><div class="ttdeci">typename templa::internal::uniform_element_identity&lt; Es... &gt; identity_type</div><div class="ttdoc">Type containing the uniform array of input values.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:263</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1unique_html_aaf25d9685d1c733798ea8cd1f7d62dcd"><div class="ttname"><a href="structtempla_1_1algorithms_1_1unique.html#aaf25d9685d1c733798ea8cd1f7d62dcd">templa::algorithms::unique::unique_sequence</a></div><div class="ttdeci">static constexpr auto unique_sequence</div><div class="ttdoc">The resulting array with unique elements from the input pack.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:275</div></div>
<div class="ttc" id="astructtempla_1_1algorithms_1_1unique_html_acc0d2c188afe3cd0ae5406397b7275b0"><div class="ttname"><a href="structtempla_1_1algorithms_1_1unique.html#acc0d2c188afe3cd0ae5406397b7275b0">templa::algorithms::unique::old_array_type</a></div><div class="ttdeci">typename identity_type::uniform_type old_array_type</div><div class="ttdoc">The type of the original uniform array.</div><div class="ttdef"><b>Definition</b> algorithms.hpp:266</div></div>
<div class="ttc" id="astructtempla_1_1internal_1_1forward__elements__from_html"><div class="ttname"><a href="structtempla_1_1internal_1_1forward__elements__from.html">templa::internal::forward_elements_from</a></div><div class="ttdoc">Extract elements from a container-like template parameter as a new container.</div><div class="ttdef"><b>Definition</b> pack.hpp:95</div></div>
<div class="ttc" id="astructtempla_1_1internal_1_1forward__elements__from_html_a8481749e857c4a6908eeecd09acf7946"><div class="ttname"><a href="structtempla_1_1internal_1_1forward__elements__from.html#a8481749e857c4a6908eeecd09acf7946">templa::internal::forward_elements_from::type</a></div><div class="ttdeci">decltype(a)::value_type type</div><div class="ttdoc">Value type of the container.</div><div class="ttdef"><b>Definition</b> pack.hpp:97</div></div>
<div class="ttc" id="astructtempla_1_1internal_1_1forward__elements__from_html_af0276070351472eb48e6b1cb13a9f5e7"><div class="ttname"><a href="structtempla_1_1internal_1_1forward__elements__from.html#af0276070351472eb48e6b1cb13a9f5e7">templa::internal::forward_elements_from::value</a></div><div class="ttdeci">static constexpr auto value</div><div class="ttdoc">Compile-time generated container with the elements of a. Uses index_sequence to access each element.</div><div class="ttdef"><b>Definition</b> pack.hpp:103</div></div>
<div class="ttc" id="astructtempla_1_1internal_1_1uniform__element__identity_html"><div class="ttname"><a href="structtempla_1_1internal_1_1uniform__element__identity.html">templa::internal::uniform_element_identity</a></div><div class="ttdoc">Uniform element identity helper for a list of values.</div><div class="ttdef"><b>Definition</b> pack.hpp:121</div></div>
<div class="ttc" id="astructtempla_1_1internal_1_1uniform__element__identity_html_a34177c2d47c12125d0992c64cfa62fb3"><div class="ttname"><a href="structtempla_1_1internal_1_1uniform__element__identity.html#a34177c2d47c12125d0992c64cfa62fb3">templa::internal::uniform_element_identity&lt; Es... &gt;::value_type</a></div><div class="ttdeci">typename uniform_type::value_type value_type</div><div class="ttdef"><b>Definition</b> pack.hpp:147</div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
