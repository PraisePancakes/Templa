\doxysection{templa\+::algorithms Namespace Reference}
\hypertarget{namespacetempla_1_1algorithms}{}\label{namespacetempla_1_1algorithms}\index{templa::algorithms@{templa::algorithms}}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespacetempla_1_1algorithms_1_1internal}{internal}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structtempla_1_1algorithms_1_1join}{join}}
\item 
struct \mbox{\hyperlink{structtempla_1_1algorithms_1_1max}{max}}
\item 
struct \mbox{\hyperlink{structtempla_1_1algorithms_1_1max__from}{max\+\_\+from}}
\item 
struct \mbox{\hyperlink{structtempla_1_1algorithms_1_1min}{min}}
\item 
struct \mbox{\hyperlink{structtempla_1_1algorithms_1_1min__from}{min\+\_\+from}}
\item 
struct \mbox{\hyperlink{structtempla_1_1algorithms_1_1reverse}{reverse}}
\item 
struct \mbox{\hyperlink{structtempla_1_1algorithms_1_1reverse__from}{reverse\+\_\+from}}
\item 
struct \mbox{\hyperlink{structtempla_1_1algorithms_1_1unique}{unique}}
\item 
struct \mbox{\hyperlink{structtempla_1_1algorithms_1_1unique__from}{unique\+\_\+from}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T, typename... Formats, std\+::size\+\_\+t N, std\+::size\+\_\+t... Is$>$ }\\std\+::tuple$<$ Formats... $>$ \mbox{\hyperlink{namespacetempla_1_1algorithms_a615dacb23cae5900f7d5e44b42344807}{as\+\_\+tuple}} (std\+::array$<$ T, N $>$ const \&arr, std\+::index\+\_\+sequence$<$ Is... $>$)
\begin{DoxyCompactList}\small\item\em Converts a fixed-\/size array into a tuple using specified format types. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T, typename... Formats, std\+::size\+\_\+t N$>$ }\\std\+::tuple$<$ Formats... $>$ \mbox{\hyperlink{namespacetempla_1_1algorithms_ab006f0d75aaa584bb3f7b9f8279abb2f}{as\+\_\+tuple}} (std\+::array$<$ T, N $>$ const \&arr)
\item 
{\footnotesize template$<$typename T, typename O$>$ }\\void \mbox{\hyperlink{namespacetempla_1_1algorithms_a4b86c02bb96b024b95841f2268e6e0f8}{flatten}} (const std\+::vector$<$ T $>$ \&in, std\+::vector$<$ O $>$ \&out)
\item 
{\footnotesize template$<$typename T, typename O$>$ }\\void \mbox{\hyperlink{namespacetempla_1_1algorithms_a4586d12315030607c285a5e03a38ba0d}{flatten}} (const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&in, std\+::vector$<$ O $>$ \&out)
\end{DoxyCompactItemize}


\label{doc-func-members}
\Hypertarget{namespacetempla_1_1algorithms_doc-func-members}
\doxysubsection{Function Documentation}
\Hypertarget{namespacetempla_1_1algorithms_ab006f0d75aaa584bb3f7b9f8279abb2f}\index{templa::algorithms@{templa::algorithms}!as\_tuple@{as\_tuple}}
\index{as\_tuple@{as\_tuple}!templa::algorithms@{templa::algorithms}}
\doxysubsubsection{\texorpdfstring{as\_tuple()}{as\_tuple()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacetempla_1_1algorithms_ab006f0d75aaa584bb3f7b9f8279abb2f} 
template$<$typename T, typename... Formats, std\+::size\+\_\+t N$>$ \\
std\+::tuple$<$ Formats... $>$ templa\+::algorithms\+::as\+\_\+tuple (\begin{DoxyParamCaption}\item[{std\+::array$<$ T, N $>$ const \&}]{arr}{}\end{DoxyParamCaption})}

\Hypertarget{namespacetempla_1_1algorithms_a615dacb23cae5900f7d5e44b42344807}\index{templa::algorithms@{templa::algorithms}!as\_tuple@{as\_tuple}}
\index{as\_tuple@{as\_tuple}!templa::algorithms@{templa::algorithms}}
\doxysubsubsection{\texorpdfstring{as\_tuple()}{as\_tuple()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacetempla_1_1algorithms_a615dacb23cae5900f7d5e44b42344807} 
template$<$typename T, typename... Formats, std\+::size\+\_\+t N, std\+::size\+\_\+t... Is$>$ \\
std\+::tuple$<$ Formats... $>$ templa\+::algorithms\+::as\+\_\+tuple (\begin{DoxyParamCaption}\item[{std\+::array$<$ T, N $>$ const \&}]{arr}{, }\item[{std\+::index\+\_\+sequence$<$ Is... $>$}]{}{}\end{DoxyParamCaption})}



Converts a fixed-\/size array into a tuple using specified format types. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The element type of the input std\+::array. \\
\hline
{\em Formats} & A parameter pack representing the target types for each tuple element. \\
\hline
{\em N} & The size of the input array. \\
\hline
{\em Is} & A parameter pack of indices used to access elements in the array.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em arr} & The input std\+::array of type T with N elements. \\
\hline
{\em std\+::index\+\_\+sequence$<$\+Is...$>$} & used to unpack array indices at compile time.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::tuple$<$\+Formats...$>$ A tuple containing elements of the array converted to the specified format types.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of elements in {\ttfamily Formats...} must match the number of indices in {\ttfamily Is...}. 
\end{DoxyNote}
\Hypertarget{namespacetempla_1_1algorithms_a4586d12315030607c285a5e03a38ba0d}\index{templa::algorithms@{templa::algorithms}!flatten@{flatten}}
\index{flatten@{flatten}!templa::algorithms@{templa::algorithms}}
\doxysubsubsection{\texorpdfstring{flatten()}{flatten()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacetempla_1_1algorithms_a4586d12315030607c285a5e03a38ba0d} 
template$<$typename T, typename O$>$ \\
void templa\+::algorithms\+::flatten (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&}]{in}{, }\item[{std\+::vector$<$ O $>$ \&}]{out}{}\end{DoxyParamCaption})}

\Hypertarget{namespacetempla_1_1algorithms_a4b86c02bb96b024b95841f2268e6e0f8}\index{templa::algorithms@{templa::algorithms}!flatten@{flatten}}
\index{flatten@{flatten}!templa::algorithms@{templa::algorithms}}
\doxysubsubsection{\texorpdfstring{flatten()}{flatten()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacetempla_1_1algorithms_a4b86c02bb96b024b95841f2268e6e0f8} 
template$<$typename T, typename O$>$ \\
void templa\+::algorithms\+::flatten (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{in}{, }\item[{std\+::vector$<$ O $>$ \&}]{out}{}\end{DoxyParamCaption})}

